function handles=mkraycoverage(stations,sources,vmodel,phaselist,linespecs,mode);
% mkraycoverage........plot ray coverage for given source/receiver geometry
%
% call: handles=mkraycoverage(stations,hypocenters,vmodel,phaselist,linespecs,mode);
%
%       stations: (struct)
%                 structure containing the receiver names and locations
%                 This structure consists of the following fields:
%
%                 .name: (string)
%                        String containing the station name
%
%                 .lon: (number) [deg]
%                       station site longitude, from 0 to 360 eastward
%
%                 .lat: (number) [deg]
%                       station site latitude, from -90 to 90, northward
%
%
%       sources: (numeric array)
%                array containing the hypocentral positions of the sources
%
%                sources(i,:) gives the position of the i-th source
%
%                source(:,1): source longitudes [deg]
%                source(:,2): source latitudes [deg]
%                source(:,3): source depths [deg]
%
%       vmodel: (struct)
%               velocity model
%               This is a strucutre as returned by MKREADND
%
%       phaselist: (string matrix)
%                  This is a matrix as created by stvcat(), containing the
%                  names of the phases that shall be evaluated, like
%                  phaselist=strvcat('P','S','PKP'...
%
%       linespecs: (string matrix)
%                 This is a matrix as created by strvcat, containing the
%                 line style specifications to be used to plot tha rays.
%                 The entries of this matrix correspond to those of
%                 PHASELIST, i.e. the i-th phase is drawn using the i-th
%                 linespec.
%                 Each line speicifer might define line style, marker and
%                 color as documented in the LineSpec page of the MatLab
%                 help (the string is passed directly to the plot command).
%
%                 This might be the empty matrix []. In that case, all
%                 rays will be drawn using 'b-'
%
%       mode: (string)
%             drawing mode selector
%
%             This string controls which type of plot will be generated.
%             possible values are:
%
%             '2D': a two-dimensional plot will be generated which is
%                   similar in layout to the plots generated by MKRAYFAN
%                   This is a sice through the planet in north-south
%                   direction onto which everything is ROTATED (by rotation
%                   around the poar axis of the planet).
%                   This does not reproduce the true ray paths, but
%                   generates a somewhat cartoon-like scheme.
%
%              '3D': a three-dimensional plot will be generated in which
%                    the planet is drawn as a sphere and stations, sources
%                    and rays will be at their correct 3D positions
%
% result: handles: (struct)
%                  structure containing the handles of all generated
%                  graphics objects. These are ordered in separate fields:
%
%                  .stations: handles to station symbols
%                  .sources:  handles to source symbols
%                  .rays:     handles to ray paths
%
%
% The stations, sources and a 3D coordinate frame drawn by MKRAYCOVERAGE in
% 3D mode can be identified by the UserData property, which contains the
% string "decoration".
%
%
% Martin Knapmeyer, 05.11.2010, 29.06.2011





%% a useful constant
radian=pi/180;


%% understand input
mode=lower(mode);


%% plot symbols
stationcolor=[0 1 1];
stationsymbol='s';
stationsize=10;
sourcecolor=[1 0 0];
sourcesymbol='o';
sourcesize=4;


%% how many stations?
statcnt=length(stations);

%% how many sources?
sourcecnt=size(sources,1);

%% how many phases?
phasecnt=size(phaselist,1);

%% prepare output
handles=[];
stationhandles=zeros(statcnt,1);
sourcehandles=zeros(sourcecnt,1);
rayhandles=[];


%% complete discontinuity list
%%% the discontinuity names defined here are referred later when searching for appropriate
%%% take off angles. Names are hard-coded in the later parts of the program! (I know it's bad style)
dz=[vmodel.conr...
    vmodel.moho...
    vmodel.d410...
    vmodel.d520...
    vmodel.d660...
    vmodel.cmb...
    vmodel.icb...
    vmodel.dz];
dname=strvcat('Conrad',...
              'Moho',...
              'Olivine ab',...
              'Olivine bg',...
              'Olivine Perovskite',...
              'CMB',...
              'ICB',...
              vmodel.dname); % discontinuity names
dcnt=length(dz); % so many discontinuities


%% reduce 3D source distribution to 2D in 2D mode
%%% in 2D mode, all sources and receivers are rotated along the longitude
%%% axis ushc that they finally are in the 0deg longitude plane. This
%%% changes the ray paths compared to the true 3D paths, but results in
%%% more readable plots is many sources, many receivers, or many phases are
%%% involved.
%%% the 90deg longitud plane defines the boundary between left and right
%%% halves of the resulting plot
if strcmp(mode,'2d')==1
   
   
   %%% modify station coordinates
   for statnr=1:statcnt
      
       currentlon=stations(statnr).lon;
       currentlat=stations(statnr).lat;
       
       %%% transform longitudes into -180...180 frame
       if currentlon>180
          currentlon=currentlon-360;
       end; % if currentlon>180
      
       if (currentlon>-90)&(currentlon<90)
          %%% longitude is on the 0N0E half of the planet
          currentlat=currentlat;
       else
          %%% longitude is on the 0N180E half of the planet
          currentlat=180-currentlat;
       end; % if (sources(sourcenr,1)>-90)&(sources(sourcenr,1)<90)
       
       if currentlat<0
          currentlat=360+currentlat;
       end; % if currentlat<0
       
       stations(statnr).lon=0;
       stations(statnr).lat=currentlat;
       
   end; % for sourcenr
   
   
   %%% modify source coordinates
   for sourcenr=1:sourcecnt
      
       currentlon=sources(sourcenr,1);
       currentlat=sources(sourcenr,2);
       
       %%% transform longitudes into -180...180 frame
       if currentlon>180
          currentlon=currentlon-360;
       end; % if currentlon>180
      
       if (currentlon>-90)&(currentlon<90)
          %%% longitude is on the 0N0E half of the planet
          currentlat=currentlat;
       else
          %%% longitude is on the 0N180E half of the planet
          currentlat=180-currentlat;
       end; % if (sources(sourcenr,1)>-90)&(sources(sourcenr,1)<90)
       
        if currentlat<0
          currentlat=360+currentlat;
       end; % if currentlat<0
       
       sources(sourcenr,1)=0;
       sources(sourcenr,2)=currentlat;
       
   end; % for sourcenr
   
end; % if strcmp(mode,'2d')==1


%% plot source and receiver distribution
switch mode
   case {'2d'}
       
        
        %%% plot polar frame if not in hold mode
        if ~ishold
           mkpolarframe(vmodel.rp,dz,0.05,[1 5 10 30 90],[0.3 0.75 1 1 2],[0 0 0 0 0]);
        end; % % if  ~ishold
        
        %%% plot stations
        for statnr=1:statcnt
           
            %%% make angle run clockwise from -1/0
            plotlat=-stations(statnr).lat-180;
            
            %%% prepare plot coordinates
            [plotx,ploty]=pol2cart(plotlat*radian,vmodel.rp);
            
            %%% plot
            hold on
            stationhandles(statnr)=plot(plotx,ploty,stationsymbol);
            %text(plotx,ploty,[stations(statnr).name],...
            %     'Rotation',shiftedlat+180,...
            %     'HorizontalAlignment','right',...
            %     'VerticalAlignment','top',...
            %     'BackGroundColor','w',...
            %     'EdgeColor','k');
            hold off
            
        end; % for statnr
        set(stationhandles,'MarkerSize',stationsize);
        set(stationhandles,'MarkerFaceColor',stationcolor);
        set(stationhandles,'MarkerEdgeColor','k');
        
        %%% plot sources
        for sourcenr=1:sourcecnt
           
           %%% make angle run clockwise from -1/0
           plotlat=-sources(sourcenr,2)-180;
            
           %%% prepare plot coordinates
           [plotx,ploty]=pol2cart(plotlat*radian,vmodel.rp-sources(sourcenr,3));
            
           %%% plot
           hold on
           sourcehandles(sourcenr)=plot(plotx,ploty,sourcesymbol);
           hold off
           set(sourcehandles(sourcenr),'UserData',sourcenr);
            
        end; % for statnr
        set(sourcehandles,'MarkerSize',sourcesize);
        set(sourcehandles,'MarkerFaceColor',sourcecolor);
        set(sourcehandles,'MarkerEdgeColor','k');
      
   case {'3d'}
      
        
        
        if ~ishold
           %%% if not in hodl mode,
           %%% plot nested spheres to denote discontinuities and surface
           %%% for now, plot only surface, CMB and ICB, to keep it simple
           [sx,sy,sz]=sphere(36);
           %%% plot surface
           sphradius=vmodel.rp;
           surfacehandle=surf(sx*sphradius,sy*sphradius,sz*sphradius);
           %%% plot CMB
           if ~isnan(vmodel.cmb)
              sphradius=vmodel.rp-vmodel.cmb;
              hold on
              cmbhandle=surf(sx*sphradius,sy*sphradius,sz*sphradius);
              hold off
           else
              cmbhandle=[];
           end; % if ~isnan
           %%% plot ICB
           if ~isnan(vmodel.icb)
              sphradius=vmodel.rp-vmodel.icb;
              hold on
              icbhandle=surf(sx*sphradius,sy*sphradius,sz*sphradius);
              hold off
           else
              icbhandle=[];
           end; % if ~isnan
           set([surfacehandle,cmbhandle,icbhandle],'FaceAlpha',0.2);
           set([surfacehandle,cmbhandle,icbhandle],'EdgeAlpha',0.1);
           set([surfacehandle,cmbhandle,icbhandle],'EdgeColor',[1 1 1]*0.5);
           set([surfacehandle,cmbhandle,icbhandle],'FaceColor',[1 1 1]*0.75);
           axis tight
           axis vis3d
           axis off
        end; % if ~ishold
        
        
        %%% plot coordinate axes
        coordaxlength=vmodel.rp*1.5;
        hold on
        h=plot3([0 0 1]*coordaxlength,[0 0 0]*coordaxlength,[0 0 0]*coordaxlength,'k-');
        set(h,'UserData','decoration');
        h=plot3([0 0 0]*coordaxlength,[0 0 1]*coordaxlength,[0 0 0]*coordaxlength,'k-');
        set(h,'UserData','decoration');
        h=plot3([0 0 0]*coordaxlength,[0 0 0]*coordaxlength,[0 0 1]*coordaxlength,'k-');
        set(h,'UserData','decoration');
        hold off
        
        
        %%% plot stations
        [sx,sy,sz]=sphere(6);
        sx=sx*vmodel.rp/20;
        sy=sy*vmodel.rp/20;
        sz=sz*vmodel.rp/20;
        for statnr=1:statcnt
            
            %%% prepare plot coordinates
            [plotx,ploty,plotz]=sph2cart(stations(statnr).lon*radian,...
                                         stations(statnr).lat*radian,...
                                         vmodel.rp);
            
            %%% plot
            hold on
            stationhandles(statnr)=surf(sx+plotx,sy+ploty,sz+plotz);
            %text(plotx,ploty,[stations(statnr).name],...
            %     'Rotation',shiftedlat+180,...
            %     'HorizontalAlignment','right',...
            %    'VerticalAlignment','top',...
            %     'BackGroundColor','w',...
            %     'EdgeColor','k');
            hold off
            
        end; % for statnr
        set(stationhandles,'FaceColor',stationcolor);
        set(stationhandles,'EdgeColor','none');
        set(stationhandles,'UserData','decoration');
        
        
        
        %%% plot sources
        [sx,sy,sz]=sphere(6);
        sx=sx*vmodel.rp/60;
        sy=sy*vmodel.rp/60;
        sz=sz*vmodel.rp/60;
        for sourcenr=1:sourcecnt
            
            %%% prepare plot coordinates
            [plotx,ploty,plotz]=sph2cart(sources(sourcenr,1)*radian,...
                                         sources(sourcenr,2)*radian,...
                                         vmodel.rp-sources(sourcenr,3));
            
            %%% plot
            hold on
            sourcehandles(sourcenr)=surf(sx+plotx,sy+ploty,sz+plotz);
            hold off
            
        end; % for statnr
        set(sourcehandles,'FaceColor',sourcecolor);
        set(sourcehandles,'EdgeColor','none');
        set(sourcehandles,'UserData','decoration');
        
        
   otherwise
        error(['MKRAYCOVERAGE: unknown plot mode ' upper(mode)]);
end; % switch mode
drawnow;


%% computation loop
%%% loop over all station/source/phase combinations
 for sourcenr=1:sourcecnt
    
    %%% current source
    currentlon=sources(sourcenr,1);
    currentlat=sources(sourcenr,2);
    currenth=sources(sourcenr,3);
    
    %%% transform source coordinates into 0...360, -90...90 convention
    %%% assume coordinates are in -180...360, -90...90 convention
    if currentlon<0
       currentlon=360+currentlon;
    end; % if currentlon
    
    

    %%% velocity at source
    %%% determine velocity at source depth (needed for angle-ray parm conversion)
    %%% if h is a discontinuity depth, there will be two velocioty values.
    %%% vp(1) (or vs(1)) will be for above discontinuity, vp(2) (or vs(2)) for below.
    focus=mkinterpmodel(vmodel,currenth,'simple');
    indy=find(focus.z==currenth);
    vp=focus.vp(indy);
    vs=focus.vs(indy);

     %% loop over all stations
     for statnr=1:statcnt 
        
        
        %%% transform station corrdinates into 0...360, -90...90 convention
        currentstatlon=stations(statnr).lon;
        if currentstatlon<0
           currentstatlon=360+currentstatlon;
        end; % if currentstatlon
        currentstatlat=stations(statnr).lat;
        
        %%% epicentral distance
        distance=mklsepidist(currentlon,currentlat,...
                             currentstatlon,currentstatlat);
                          
        %%% azimuth from source to station
        azimuth=mklsbaz(currentstatlat,currentstatlon,...
                        currentlat,currentlon);
                     
        %%% what are we currently doing?
        %disp(['MKRAYCOVERAGE: epicentral distance: ' num2str(distance)...
        %     ' Source-Receiver Azi.: ' num2str(azimuth)]);
                          
        
        %% loop over all phases
        for phasenr=1:phasecnt

               currentphase=deblank(phaselist(phasenr,:));

               %%% determine take off angles etc
               syn=mksynopsis(distance,currenth,vmodel,currentphase,'on');
               
               
               %% handle multipathing
               %%% identify all solutions that are
               %%% within some epsilon of the desired distance, and loop
               %%% over these
               validsolutions=find(abs(syn.d-distance)<0.1);
               validcnt=length(validsolutions);

               for validnr=1:validsolutions
                  
                  %%% take off angle of current valid solution
                  currentangle=syn.a(validsolutions(validcnt));
                  
                  %%% compute ray geometry
                  [covereddist,rx,rz,rt,resp]=mkx4p(currentphase,currenth,...
                                             currentangle,vmodel,'angle');
                                          
       

                  %% plot ray geometry
                  switch mode
                     case {'2d'}
                        %% 2D plotting mode 
                       
                        
                        %%% 2D plot means: use the latitude coordinates as
                        %%% "epicentral distance" in a 2D polarframe
                        
                        %% make distance count clockwise from -1/0 as in
                        %%% rayfan plots
                        rx=-rx-180;
%                         if currentlat<=180
%                            rx=-rx-180;
%                         else
%                            if currentlat>180
%                               rx=180+rx;
%                            end; %
%                         end; %
                        
                       
                        
                        
                        
                        %% turn around phases if delta>180
                        %%% if a phase covers more than 180 deg, e.g. a PP
                        %%% phase reaching the receiver from the other
                        %%% direction than P, the propagatin direction has
                        %%% to be flipped
                        %%% it also has to be flipped if the
                        %%% counterclockwise path is taken instead of the
                        %%% clockwise path
                        angledir=mkangledir(currentlat,currentstatlat);
                        rx=rx*angledir*sign(180-covereddist);
                      %  counterclock=360-clockwise;
%                         if clockwise<0 %abs(rx(end)-clockwise)<abs(rx(end)-counterclock)
%                            %%% running clockwise brings us closer to
%                            %%% receiver
%                            rx=-rx;
%                         else
%                            %%% running counterclockwise brings us closer to
%                            %%% receiver
%                            rx=rx;
%                         end; % if if abs(covereddist-clockwise)<abs(covereddist-counterclock)
%                         if (currentstatlat-currentlat)==covereddist %xor((covereddist>180),(currentstatlat-currentlat>180))
%                            rx=-rx;
%                         end; % if covereddist


                        %% make the ray run from source to receiver
                        %%% rotate around the off-plane axis through the
                        %%% middle of the planet
                        
                        %%% create empty arrays for the ray coordinates
                        raylat=zeros(size(rx));
                        rayrad=zeros(size(rz));
                        
                        %%% fill with distances and radii
                        raylat=rx;
                        rayrad=vmodel.rp-rz;

                        %%% rotate to source latitude
                        raylat=raylat-currentlat;
                        
                        
%                         %% turn around phases if delta>180
%                         %%% if a phase covers more than 180 deg, e.g. a PP
%                         %%% phase reaching the receiver from the other
%                         %%% direction than P, the propagatin direction has
%                         %%% to be flipped
%                         %%% it also has to be flipped if the
%                         %%% counterclockwise path is taken instead of the
%                         %%% clockwise path
%                         clockwise=currentstatlat-currentlat;
%                         counterclock=360-clockwise;
%                         if abs(raylat(end)-clockwise)<abs(raylat(end)-counterclock)
%                            %%% running clockwise brings us closer to
%                            %%% receiver
%                            raylat=raylat;
%                         else
%                            %%% running counterclockwise brings us closer to
%                            %%% receiver
%                            raylat=-raylat;
%                         end; % if if abs(covereddist-clockwise)<abs(covereddist-counterclock)
                        
                        
                        
                        %% convert into cartesian coordinates
                        [rayx,rayy]=pol2cart(raylat*radian,rayrad);
                        
                        %% plot the resulting ray
                        
                        %%% current line specifier
                        if ~isempty(linespecs)
                           currentlinespec=deblank(linespecs(phasenr,:));
                        else
                           currentlinespec='b-';
                        end; % if ~isempty(linespecs)
                        
                        %%% plot projected ray paths
                        hold on
                        thisray=plot(rayx,rayy,currentlinespec);
                        hold off
                        drawnow;
                        rayhandles=[rayhandles; thisray];
                        
                        
                          
                         
                          
                          
                     case {'3d'}
                        %% 3D plotting mode
                        
                        
                        %% make the ray run from source to receiver...
                        %%% the ray geometry should be considered as describing a ray
                        %%% ray starting at 0N 0E at the equator and traveling in
                        %%% the plane defined by 0N0E and the poles. Then it
                        %%% needs to be rotated
                        %%% a) to start at the source longitude
                        %%% b) to start at the source latitude
                        %%% c) to end at the receiver
                        %%% Lots of rotations to do...

                        %% first: create proper spherical coordinates from the
                        %%% mkx4p output. Be aware of the effect of the North pole
                        %%% on these coordinates!

                        %%% prepare rey coordinate variables
                        raylon=zeros(size(rx));
                        raylat=zeros(size(rx));
                        rayrad=zeros(size(rz));

                        %%% ray coordinates within source-pole-pole plane
                        %%% note that at this point of the computation, the
                        %%% source is at 0,0, and thus its colatitude is 90deg!
                        %%% in any case!!
                        currentcolat=90-0; 
                        raylat=rx;
                        beyondpole=find(raylat>currentcolat);
                        raylat(beyondpole)=90-(raylat(beyondpole)-currentcolat);
                        raylon(beyondpole)=raylon(beyondpole)+180;
                        rayrad=vmodel.rp-rz;


                        %% second: rotate to source latitude
                        %%% this brings the source of the ray from 0N0E to
                        %%% sourcelat,0E
                        %%% this is a rotation about the Y axis that is done best
                        %%% in cartesian coordinates
                        [rayx,rayy,rayz]=sph2cart(raylon*radian,raylat*radian,rayrad);
                        alpha=-currentlat*radian; % rotation angle, called alpha for clarity with the matrix source...
                        ymatrix=[cos(alpha) 0 sin(alpha);...
                                     0      1      0    ;...
                                -sin(alpha) 0 cos(alpha)];
                        unrotated=[rayx; rayy; rayz];
                        rotated=ymatrix*unrotated;
                        rayx=rotated(1,:);
                        rayy=rotated(2,:);
                        rayz=rotated(3,:);
                        
                        %% third: rotate to source longitude
                        %%% this brings the source of the ray from sourcelat, 0E
                        %%% to sourcelat, sourcelon
                        %%% the rotation itself can be done by simply adding an
                        %%% angle increment and is thus done best in polar
                        %%% coordinates (but this has to be the second step to keep the
                        %%% rotations simple - the price to be paid is the back-and-forth
                        %%% transformation...)
                        %%% back to spherical
                        [raylon,raylat,rayrad]=cart2sph(rayx,rayy,rayz);
                        raylon=raylon/radian;
                        raylat=raylat/radian;
                        %%% the rotation itself
                        raylon=raylon+currentlon;
                        %%% it's nice to reduce everything to the 0...360
                        %%% interval (unwrap) (assuming that we currently are in
                        %%% 0...720 interval because of input limitation)
                        beyond360=find(raylon>360);
                        raylon(beyond360)=raylon(beyond360)-360;



                        %% fourth: rotate into proper source-to-receiver azimuth
                        %%% this brings the end of the ray to the receiver
                        %%% coordinates
                        %%% The rotation axis is defined by source location and
                        %%% planet center, the rotation angle is the azimuth
                        %%% computed above using mklsbaz
                        %%% This, again, should be done in cartesian coordinates
                        %%% forth to cartesian
                        [rayx,rayy,rayz]=sph2cart(raylon*radian,raylat*radian,rayrad);
                        %%% rotation axis: unit vector through center and source
                        [cx,cy,cz]=sph2cart(currentlon*radian,currentlat*radian,1);
                        rotationaxis=[cx cy cz];
                        %%% effective rotation angle
                        if covereddist>180
                           effectiveazimuth=azimuth+180;
                        else
                           effectiveazimuth=azimuth;
                        end; % if covereddist>180
                        %%% apply quaternion rotation to each individual point
                        pointcnt=length(rayx);
                        for pointnr=1:pointcnt
                           newpoint=mkweissrot([rayx(pointnr) rayy(pointnr) rayz(pointnr)],...
                                                rotationaxis,...
                                                effectiveazimuth);
                           rayx(pointnr)=newpoint(1);
                           rayy(pointnr)=newpoint(2);
                           rayz(pointnr)=newpoint(3);
                        end; % for pointnr
                        
                        
                        %% plot the resulting ray
                        
                        %%% current line specifier
                        if ~isempty(linespecs)
                           currentlinespec=deblank(linespecs(phasenr,:));
                        else
                           currentlinespec='b-';
                        end; % if ~isempty(linespecs)


                        %%% plot ray path
                        hold on
                        thisray=plot3(rayx,rayy,rayz,currentlinespec);
                        %mkcsiplottube(rayx,rayy,rayz,sourcesize*5);
                        hold off
                        drawnow;
                        rayhandles=[rayhandles; thisray];
                        
                        
                        
                        
                     otherwise
                     error(['MKRAYCOVERAGE: unknown plot mode ' upper(mode)]);
                  end; % switch mode
                  
                  %%% write information on ray into UserData field of line
                  %%% properties
                  set(thisray,'UserData',...
                      {'Source #' num2str(sourcenr);...
                       'Rec' stations(statnr).name;...
                       'Phase' currentphase;...
                       'takeoff' num2str(currentangle);...
                       'slo' num2str(resp);...
                       'max(z)' num2str(max(rz));...
                       'Delta' num2str(covereddist)});


               end; % for validnr


        end; % for phasenr
        
     end; % for statnr
     
 end; % for sourcenr


%%% compile all handles to an output struct
handles.stations=stationhandles;
handles.sources=sourcehandles;
handles.rays=rayhandles;


%% all done
return;
