function [newp,newangle]=mkfumblep(oldp,oldangle,direction,phase,h,model);
% mkfumblep......search for existing ray around given ray parameter
%
% call: [newp,newangle]=mkfumblep(oldp,oldangle,direction,phase,h,model);
%
%            oldp: starting value for takeoff angle [deg]
%
%        oldangle: take off angle corresponding to OLDP [deg]
%                  This is needed to decide if the result ray is the
%                  upgoing or downgoing one.
%
%       direction: string denoting the search direction.
%                  The following values are possible:
%                  'up': search by increasing OLDANGLE
%                  'down': search by decreasing OLDANGLE
%                  'both': search both directions, the solution which is
%                          closer to the initial value is returned
%                          This is implemented as a recursive call to the
%                          two other modes 'up' and 'down'.
%
%           phase: string containing the seismic phase name
%
%               h: focal depth of the source [km]
%
%           model: velocity model structure as returned by MKREADND
%
% result: newp: new ray parameter [s/deg]
%               if this is a non-NaN value, it is guaranteed that the PHASE
%               exists for this ray parameter.
%               IF no such ray parameter is found, the output depends on
%               the DIRECTION:
%               - UP and DOWN: NaN is returned
%               - BOTH: the input is returned unchanged
%               This distinction is necessary because the BOTH direction is
%               used internally in recursive calls, and the NaN result is
%               needed for further processing.
%
%      newangle: new takeoff angle [deg]
%                This is the takeoff angle corresponding to NEWP.
%
% The search method is: increase/decrease OLDANGLE by amounts of varying
% size. The routine is designed for cases where small numerical errors in
% the determination of minimum and maximum possible takeoff angles lead to
% NaN results of MKX4P (e.g. when you search CMB grazing S rays).
% The routine should therefore not be used to determine the minimum and
% maximum takeoffs from without having a good starting estimate.
%
% The routine is intended to "repair" problems that arise from small
% numerical inaccuracies. Since it does not repair the inaccuracies
% themselves but just "fumbles" with the input, I chose the routine's name
% accordingly. I don't like this style, but currently have no better idea.
%
% Since most of the time, MKX4P produces NaN for candidate solutions, only
% a direct search can be used.
%
% From the two solutions for the takeoff angle (upgoing and downgoing), the
% routine chooses the one which corresponds to the input OLDANGLE
%
% Martin Knapmeyer, 29.06.2006, 20.10.2006

% 20.10.2006: recursive mode "both" implemented
%             candidate ray parameter is always generated by modifying only
%             a single digit of the input parameter, to make the result
%             more transparent



%%% init result
newp=oldp;
newangle=oldangle;


%%% init angular increments/decrements
minexponent=-10; %ceil(log10(eps)); % eps is machine epsilon
maxexponent=0;
exponents=minexponent:maxexponent;
crement=10.^exponents;


%%% search direction
direction=lower(direction);
switch direction
    case {'up'}
         crementsign=+1;
    case {'down'}
         crementsign=-1;
    case {'both'}
         %%% here we go recursive! MK20102006
         
         %%% search upward, incrementing OLDP
         [upp,upangle]=mkfumblep(oldp,oldangle,'up',phase,h,model);
         
         %%% search downward, decrementing OLDP
         [downp,downangle]=mkfumblep(oldp,oldangle,'down',phase,h,model);
         
         %%% compare the two solutions
         %%% keep in mind that one or both solutions might be NaN!
         %%% handling is easier if the two solutions are in one variable
         newp=[upp; downp];
         newangle=[upangle; downangle];
         nancnt=sum(isnan(newp)); % number of NaN solutions in NEWP
         switch nancnt
             case {0}
                 %%% both solutions are not NaN, return the one which is
                 %%% closer to the input OLDP
                 deviation=abs(newp-oldp); % difference between input an solution
                 [mindev,indy]=min(deviation); % search smallest difference
                 newp=newp(indy); % return min deviation solution
                 newangle=newangle(indy);
             case {1}
                 %%% only one solution is not NaN, so return it!
                 possible=find(~isnan(newp)); % index of non-NaN solution
                 newp=newp(possible);
                 newangle=newangle(possible);
             case {2}
                 %%% both solutions are NaN, so the input is returned
                 newp=oldp;
                 newangle=oldangle;
             otherwise
                 error(['MKFUMBLEP: unexpected number of NaN solutions.']);
         end; % switch nancnt
         
         
         %%% leave routine!
         return;
    otherwise
         error(['MKFUMBLEP: unknown search direction ' upper(direction)]);
end; % switch directions


%%% search loop
done=0;
cnt=1;
maxcnt=length(crement); % max number of loops
candidate=oldp;
%disp(candidate);
while done==0
    
%     %%% control plot
%     currentfig=gcf;
%     figure(4);
%     hold on
%     plot(cnt,abs(candidate-oldp),'o');
%     hold off
%     set(gca,'yscale','log');
%     drawnow;
%     %figure(currentfig);
    
    %%% compute ray for current candidate angle
    dist=mkx4p(phase,h,candidate,model);
    %disp(['candidate: ' num2str(candidate) ', dist=' num2str(dist)]);
    
    %%% evaluate ray tracing result
    if ~isnan(dist)
        %%% phase exists for current ray parameter, stop search
        done=1;
        newp=candidate;
    else
        %%% phase does not exist for current ray parameter, increment or
        %%% decrement angle by next CREMENT
        candidate=oldp+crementsign*crement(cnt);
        cnt=cnt+1;
        
        %%% iteration exhaust?
        if cnt==maxcnt
           %%% max number of steps reached, stop search
           done=1;
           newp=NaN;
        end; % if cnt==maxcnt
        
        %%% ray parameter negative?
        if candidate<0
           done=1;
           newp=NaN;
        end; % if candidate<0
    end; % if ~isnan(dist)
    
end; % while

%%% compute takeoff angle corresponding to NEWP
if ~isempty(newp)
    
    %%% ray parameter to angle conversion
    newangle=mkrayp2angle(phase,h,newp,model);

    %%% upgoing or downgoing sokution?
    if oldangle<90
       %%% downgoing solution
       newangle=newangle(end);
    else
       %%% upgoing solution
       newangle=newangle(1);
    end; % if oldangle<90

else
    %%% ray parameter is NaN -> angle ist also NaN.
    newangle=NaN;
end; % if ~isnan(newp)


%%% good bye.
return;


